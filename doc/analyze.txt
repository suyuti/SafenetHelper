HSM'de AES key üretilir. AES 256'dır.
Üretilen key session bazlıdır.
Üretilen key LMK altında encrypt edilerek dışarı verilir. 
KCV'si de LMK altında encrypt edilerek dışarı verilir.

LMK desteklenmeyen HSM'lerde LMK işlemleri için bir key tanımlanır.
Bu key export edilemez.
LMK key'i birden fazla olmalıdır. 
Bir de aktif LMK'yı gösteren bir işaretçi olmalıdır.
Bir session keyi üretildiğinde aktif LMK ile şifrelenerek dışarı verilir. Ayrıca aktif lmk işaretçisi de verilir.




Key life cycles & Flows
=======================
        OKC                             GIB                                   HSM
 Install:
 
 1.1.    | Pö/Sö : Create                |                                     |                                // Pö/Sö Terminalde oluşturulur.
 1.2.    |                               |                                     | Pg/Sg : Create                 // Pg/Sg HSM'de olusturulur.
 1.3.    |                               | <----[Pg]-------------------------- |                                // Pg kart ile export edilir.             (? nasıl export edilecek)
 1.4.    | <----[Pg]-------------------- |                                     |                                // Pg OKC'ye tasinir. 
 1.5.    | -----[Pö]-------------------> |                                     |                                // Pö GIB'e tasinir
 1.6.    | A: FisCalNo                   |                                     |                                // FisCalNo terminalde tanimlidir. Uniquedir.

 
 Key Exchange:
 
 2.1.    | TRMK : Create                 |                                     |                                // POS'da TRMK uretilir. AES256
 2.2.    | B: Pg(FisCalNo)               |                                     |                                // FisCalNo Pg ile sifrelenir.
 2.3.    | C: Pg(TRMK)                   |                                     |                                // TRMK Pg ile wrap edilir.
 2.4.    | D: Sö(C + A)                  |                                     |                                // C+A concat
 2.5.    | -----[B,C,D]----------------> |                                     |                                //
 2.6.    |                               |                                     |                                // GIB once FisCalNo'yu ogrenmek icin cozduruyor.
 2.7.    |                               | -----[B]--------------------------> |                                // getFisCalNo(B)
 2.8.    |                               |                                     | B': FisCalNo                   // Sg ile decrypt edilir.
 2.9.    |                               | <----[B']-------------------------- |                                // FisCalNo geri dondurulur
 2.10.   |                               | D': verify,Pö                       |                                // Pö ile verify edilir.
 2.11.   |                               |                                     |                                // GIB'de, FisCalNo terminal tablosuna eklenir 
 2.12.   |                               | -----[C]--------------------------> |                                // getTRAEK()
 2.13.   |                               |                                     | C' => TRMK                     // Sg ile unwrap edilir.
 2.14.   |                               |                                     | E: TRAK create                 // AES256, session based, key ismi random olmali. 
 2.15.   |                               |                                     | F: TREK create                 // AES256, session based, key ismi random olmali.
 2.16.   |                               |                                     | G: active Lmk Index            // ActiveLmkIndex dataObject'te tutuluyor.
 2.17.   |                               |                                     | G.1: Lmk[G]                    // LMK bulunur.
 2.18.   |                               |                                     | H: LMK(TRAK)                   // Bulunan LMK ile wrap yapilir.
 2.19.   |                               |                                     | I: LMK(TREK)                   // Bulunan LMK ile wrap yapilir.
 2.20.   |                               |                                     | J: Kcv of TRAK                 // Kcv hesaplanir.
 2.21.   |                               |                                     | K: Kcv of TREK                 // Kcv hesaplanir.
 2.22.   |                               |                                     | L: TRMK(TRAK)                  // wrap 
 2.23.   |                               |                                     | M: TRMK(TREK)                  // wrap
 2.24.   |                               |                                     | N: Sg(L+M)                     // sign
 2.25.   |                               | <----[G,H,I,J,K,L,M,N]------------- |                                // GIB'de G,H,I,J,K terminal tablosunda tutulur.
 2.26.   | <----[J,K,L,M,N]------------- |                                     |                                // Terminale geri dondurulur. 

 
  Transaction:
 
 3.1.    | O: SHA256(Data)               |                                     |                                //
 3.2.    | P: TREK(Data)                 |                                     |                                //
 3.3.    | Q: TRAK(O)                    |                                     |                                //
 3.4.    | ----[O,P,Q]-----------------> |                                     |                                //
 3.5.    |                               | -----[G,H,I,J,K,O,P,Q]------------> |                                // processFirst(G,H,I,J,K,O,P,Q)
 3.6.    |                               |                                     | G ile LMK bulunur.             //
 3.7.    |                               |                                     | H' => TRAK elde edilir.        // unwrap
 3.8.    |                               |                                     | I' => TREK elde edilir.        // unwrap
 3.9.    |                               |                                     | Kcv(H') == J ?                 // Hesaplanan H' kcv ile J esit mi?
 3.10.   |                               |                                     | Kcv(I') == K ?                 // Hesaplanan I' kcv ile K esit mi?
 3.11.   |                               |                                     | P' => Data elde edilir.        // decrypt
 3.12.   |                               |                                     | R: SHA256(P')                  // sha hesaplanır
 3.13.   |                               |                                     | Q' => SHA256(Data)             // decrypt
 3.14.   |                               |                                     | R == Q' ?                      // hesaplanan SHA ile gelen SHA karsilastirilir.
 3.15.   |                               | <----[Data]------------------------ |                                // GIB aldigi data ile islemlerini yapar.
 3.16.   |                               | S: Data'                            |                                // Islem yapilir. Response data olusturulur.
 3.17.   |                               | -----[G,H,I,J,K,S]----------------> |                                // processNext(G,H,I,J,K,S)
 3.18.   |                               |                                     | G ile LMK bulunur              // 
 3.19.   |                               |                                     | H' => TRAK elde edilir.        // unwrap
 3.20.   |                               |                                     | I' => TREK elde edilir.        // unwrap
 3.21.   |                               |                                     | Kcv(H') == J ?                 // Hesaplanan H' kcv ile J esit mi?
 3.22.   |                               |                                     | Kcv(I') == K ?                 // Hesaplanan I' kcv ile K esit mi?
 3.23.   |                               |                                     | T: SHA256(S)                   // Verinin ozeti hesaplanir.
 3.24.   |                               |                                     | U: H'(T)                       // encrypt, ozet sifrelenir.
 3.25.   |                               |                                     | V: I'(S)                       // encrypt, veri sifrelenir. 
 3.26.   |                               | <----[U,V]------------------------- |                                // 
 3.27.   | <----[U,V]------------------- |                                     |                                //
